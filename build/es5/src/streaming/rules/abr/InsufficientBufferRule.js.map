{"version":3,"sources":["../../../../../../src/streaming/rules/abr/InsufficientBufferRule.js"],"names":[],"mappings":"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","file":"InsufficientBufferRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport BufferController from '../../controllers/BufferController';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport Debug from '../../../core/Debug';\nimport SwitchRequest from '../SwitchRequest.js';\n\nfunction InsufficientBufferRule(config) {\n\n    let context = this.context;\n    let log = Debug(context).getInstance().log;\n    let eventBus = EventBus(context).getInstance();\n\n    let metricsModel = config.metricsModel;\n\n    let instance,\n        bufferStateDict,\n        lastSwitchTime,\n        waitToSwitchTime;\n\n    function setup() {\n        bufferStateDict = {};\n        lastSwitchTime = 0;\n        waitToSwitchTime = 1000;\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    }\n\n    function getMaxIndex (rulesContext) {\n        var now = new Date().getTime();\n        var mediaType = rulesContext.getMediaInfo().type;\n        var metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n        var lastBufferStateVO = (metrics.BufferState.length > 0) ? metrics.BufferState[metrics.BufferState.length - 1] : null;\n        let switchRequest = SwitchRequest(context).create();\n\n        if (now - lastSwitchTime < waitToSwitchTime ||\n            lastBufferStateVO === null) {\n            return switchRequest;\n        }\n\n        setBufferInfo(mediaType, lastBufferStateVO.state);\n        // After the sessions first buffer loaded event , if we ever have a buffer empty event we want to switch all the way down.\n        if (lastBufferStateVO.state === BufferController.BUFFER_EMPTY && bufferStateDict[mediaType].firstBufferLoadedEvent !== undefined) {\n            log('Switch to index 0; buffer is empty.');\n            switchRequest.value = 0;\n            switchRequest.reason = 'InsufficientBufferRule: Buffer is empty';\n        }\n\n        lastSwitchTime = now;\n        return switchRequest;\n    }\n\n    function setBufferInfo(type, state) {\n        bufferStateDict[type] = bufferStateDict[type] || {};\n        bufferStateDict[type].state = state;\n        if (state === BufferController.BUFFER_LOADED && !bufferStateDict[type].firstBufferLoadedEvent) {\n            bufferStateDict[type].firstBufferLoadedEvent = true;\n        }\n    }\n\n    function onPlaybackSeeking() {\n        bufferStateDict = {};\n    }\n\n    function reset() {\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        bufferStateDict = {};\n        lastSwitchTime = 0;\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nInsufficientBufferRule.__dashjs_factory_name = 'InsufficientBufferRule';\nexport default FactoryMaker.getClassFactory(InsufficientBufferRule);\n"]}