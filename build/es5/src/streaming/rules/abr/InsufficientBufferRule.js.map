{"version":3,"sources":["../../../../../../src/streaming/rules/abr/InsufficientBufferRule.js"],"names":[],"mappings":"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","file":"InsufficientBufferRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport BufferController from '../../controllers/BufferController';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport Debug from '../../../core/Debug';\nimport SwitchRequest from '../SwitchRequest.js';\n\nfunction InsufficientBufferRule(config) {\n\n    const INSUFFICIENT_BUFFER_SAFETY_FACTOR = 0.5;\n\n    let context = this.context;\n    let log = Debug(context).getInstance().log;\n    let eventBus = EventBus(context).getInstance();\n\n    let metricsModel = config.metricsModel;\n    let dashMetrics = config.dashMetrics;\n\n    let instance,\n        bufferStateDict;\n\n    function setup() {\n        resetInitialSettings();\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    }\n\n    function checkConfig() {\n        if (!metricsModel || !metricsModel.hasOwnProperty('getReadOnlyMetricsFor') || !dashMetrics || !dashMetrics.hasOwnProperty('getCurrentBufferLevel')) {\n            throw new Error('Missing config parameter(s)');\n        }\n    }\n    /*\n     * InsufficientBufferRule does not kick in before the first BUFFER_LOADED event happens. This is reset at every seek.\n     *\n     * If a BUFFER_EMPTY event happens, then InsufficientBufferRule returns switchRequest.quality=0 until BUFFER_LOADED happens.\n     *\n     * Otherwise InsufficientBufferRule gives a maximum bitrate depending on throughput and bufferLevel such that\n     * a whole fragment can be downloaded before the buffer runs out, subject to a conservative safety factor of 0.5.\n     * If the bufferLevel is low, then InsufficientBufferRule avoids rebuffering risk.\n     * If the bufferLevel is high, then InsufficientBufferRule give a high MaxIndex allowing other rules to take over.\n     */\n    function getMaxIndex (rulesContext) {\n        let switchRequest = SwitchRequest(context).create();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaType')) {\n            return switchRequest;\n        }\n\n        checkConfig();\n\n        let mediaType = rulesContext.getMediaType();\n        let metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n        let lastBufferStateVO = (metrics.BufferState.length > 0) ? metrics.BufferState[metrics.BufferState.length - 1] : null;\n\n        if (!lastBufferStateVO || !wasFirstBufferLoadedEventTriggered(mediaType, lastBufferStateVO)) {\n            return switchRequest;\n        }\n\n        if (lastBufferStateVO.state === BufferController.BUFFER_EMPTY) {\n            log('Switch to index 0; buffer is empty.');\n            switchRequest.quality = 0;\n            switchRequest.reason = 'InsufficientBufferRule: Buffer is empty';\n        } else {\n            const mediaInfo = rulesContext.getMediaInfo();\n            const abrController = rulesContext.getAbrController();\n            const throughputHistory = abrController.getThroughputHistory();\n            const trackInfo = rulesContext.getTrackInfo();\n            const fragmentDuration = trackInfo.fragmentDuration;\n\n            let bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);\n\n            let throughput = throughputHistory.getAverageThroughput(mediaType);\n            let latency = throughputHistory.getAverageLatency(mediaType);\n\n            let bitrate = throughput * (bufferLevel / fragmentDuration) * INSUFFICIENT_BUFFER_SAFETY_FACTOR;\n\n            switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, bitrate, latency);\n            switchRequest.reason = 'InsufficientBufferRule: being conservative to avoid immediate rebuffering';\n        }\n\n        return switchRequest;\n    }\n\n    function wasFirstBufferLoadedEventTriggered(mediaType, currentBufferState) {\n        bufferStateDict[mediaType] = bufferStateDict[mediaType] || {};\n\n        let wasTriggered = false;\n        if (bufferStateDict[mediaType].firstBufferLoadedEvent) {\n            wasTriggered = true;\n        } else if (currentBufferState && currentBufferState.state === BufferController.BUFFER_LOADED) {\n            bufferStateDict[mediaType].firstBufferLoadedEvent = true;\n            wasTriggered = true;\n        }\n        return wasTriggered;\n    }\n\n    function resetInitialSettings() {\n        bufferStateDict = {};\n    }\n\n    function onPlaybackSeeking() {\n        resetInitialSettings();\n    }\n\n    function reset() {\n        resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nInsufficientBufferRule.__dashjs_factory_name = 'InsufficientBufferRule';\nexport default FactoryMaker.getClassFactory(InsufficientBufferRule);\n"]}