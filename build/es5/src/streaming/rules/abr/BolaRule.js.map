{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":[],"mappings":"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","file":"BolaRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport MediaPlayerModel from '../../models/MediaPlayerModel';\nimport PlaybackController from '../../controllers/PlaybackController';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport DashAdapter from '../../../dash/DashAdapter';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune Bola behavior on seeking\nconst BOLA_STATE_ONE_BITRATE    = 0;\nconst BOLA_STATE_STARTUP        = 1;\nconst BOLA_STATE_STEADY         = 2;\nconst BOLA_DEBUG = false; // TODO: remove\n\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\nconst BUFFER_TARGET_S = 30; // If Schedule Controller does not allow buffer level to reach BUFFER_TARGET_S, this can be a placeholder buffer level.\nconst REBUFFER_SAFETY_FACTOR = 0.5; // Used when buffer level is dangerously low, might happen often in live streaming.\n\nfunction BolaRule(config) {\n\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE = 2;\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD = 3;\n\n    const context = this.context;\n    const log = Debug(context).getInstance().log;\n    const dashMetrics = config.dashMetrics;\n    const metricsModel = config.metricsModel;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        lastCallTimeDict,\n        lastFragmentLoadedDict,\n        lastFragmentWasSwitchDict,\n        eventMediaTypes,\n        mediaPlayerModel,\n        playbackController,\n        adapter;\n\n    function setup() {\n        lastCallTimeDict = {};\n        lastFragmentLoadedDict = {};\n        lastFragmentWasSwitchDict = {};\n        eventMediaTypes = [];\n        mediaPlayerModel = MediaPlayerModel(context).getInstance();\n        playbackController = PlaybackController(context).getInstance();\n        adapter = DashAdapter(context).getInstance();\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n    }\n\n    function utilitiesFromBitrates(bitrates) {\n        return bitrates.map(b => Math.log(b));\n        // no need to worry about offset, any offset will be compensated for by gp\n    }\n\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n    function calculateParameters(minimumBufferS, bufferTargetS, bitrates, utilities) {\n        let highestUtilityIndex = NaN;\n        if (!utilities) {\n            utilities = utilitiesFromBitrates(bitrates);\n            highestUtilityIndex = utilities.length - 1;\n        } else {\n            highestUtilityIndex = 0;\n            utilities.forEach((u, i) => {if (u > utilities[highestUtilityIndex]) highestUtilityIndex = i;});\n        }\n\n        if (highestUtilityIndex === 0) {\n            // if highestUtilityIndex === 0, then always use lowest bitrate\n            return null;\n        }\n\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTargetS.\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n        // Vp * (utilities[0] + gp - 1) = minimumBufferS and Vp * (utilities[max] + gp - 1) = bufferTargetS\n        // giving:\n        const gp = 1 - utilities[0] + (utilities[highestUtilityIndex] - utilities[0]) / (bufferTargetS / minimumBufferS - 1);\n        const Vp = minimumBufferS / (utilities[0] + gp - 1);\n\n        return {utilities: utilities, gp: gp, Vp: Vp};\n    }\n\n    function calculateInitialState(rulesContext) {\n        let initialState = {};\n\n        const mediaInfo = rulesContext.getMediaInfo();\n\n        const streamProcessor = rulesContext.getStreamProcessor();\n        const streamInfo = rulesContext.getStreamInfo();\n        const trackInfo = rulesContext.getTrackInfo();\n\n        const isDynamic = streamProcessor.isDynamic();\n        const duration = streamInfo.manifestInfo.duration;\n        const fragmentDuration = trackInfo.fragmentDuration;\n\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        const params = calculateParameters(MINIMUM_BUFFER_S, BUFFER_TARGET_S, bitrates, null);\n        if (params === null) {\n            // The best soloution is to always use the lowest bitrate...\n            initialState.state = BOLA_STATE_ONE_BITRATE;\n            return initialState;\n        }\n\n        initialState.state                 = BOLA_STATE_STARTUP;\n\n        initialState.bitrates              = bitrates;\n        initialState.utilities             = params.utilities;\n        initialState.Vp                    = params.Vp;\n        initialState.gp                    = params.gp;\n\n        initialState.isDynamic             = isDynamic;\n        initialState.movieDuration         = duration;\n        initialState.fragmentDuration      = fragmentDuration;\n        initialState.bandwidthSafetyFactor = mediaPlayerModel.getBandwidthSafetyFactor();\n        initialState.rebufferSafetyFactor  = REBUFFER_SAFETY_FACTOR;\n        initialState.bufferTarget          = mediaPlayerModel.getStableBufferTime();\n\n        initialState.lastQuality           = 0;\n        initialState.placeholderBuffer     = 0;\n        initialState.throughputCount       = (isDynamic ? AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE : AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD);\n\n        if (BOLA_DEBUG) {\n            let info = '';\n            for (let i = 0; i < bitrates.length; ++i) {\n                let u  = params.utilities[i];\n                let b  = bitrates[i];\n                let th = 0;\n                if (i > 0) {\n                    let u1 = params.utilities[i - 1];\n                    let b1 = bitrates[i - 1];\n                    th  = params.Vp * ((u1 * b - u * b1) / (b - b1) + params.gp);\n                }\n                let z = params.Vp * (u + params.gp);\n                info += '\\n' + i + ':' + (0.000001 * bitrates[i]).toFixed(3) + 'Mbps ' + th.toFixed(3) + '/' + z.toFixed(3);\n            }\n            log('BolaDebug ' + mediaInfo.type + ' bitrates' + info);\n        }\n\n        return initialState;\n    }\n\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\n        const bitrateCount = bolaState.bitrates.length;\n        let quality = NaN;\n        let score = NaN;\n        for (let i = 0; i < bitrateCount; ++i) {\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n            if (isNaN(score) || s >= score) {\n                score = s;\n                quality = i;\n            }\n        }\n        return quality;\n    }\n\n    function getLastHttpRequests(metrics, count) {\n        let allHttpRequests = dashMetrics.getHttpRequests(metrics);\n        let httpRequests = [];\n\n        for (let i = allHttpRequests.length - 1; i >= 0 && httpRequests.length < count; --i) {\n            let request = allHttpRequests[i];\n            if (request.type === HTTPRequest.MEDIA_SEGMENT_TYPE && request._tfinish && request.tresponse && request.trace) {\n                httpRequests.push(request);\n            }\n        }\n\n        return httpRequests;\n    }\n\n    function getRecentThroughput(metrics, count, mediaType) { // TODO: mediaType only used for debugging, remove it\n        let lastRequests = getLastHttpRequests(metrics, count);\n        if (lastRequests.length === 0) {\n            return 0;\n        }\n\n        let totalInverse = 0;\n        let msg = '';\n        for (let i = 0; i < lastRequests.length; ++i) {\n            // The RTT delay results in a lower throughput. We can avoid this delay in the calculation, but we do not want to.\n            let downloadSeconds = 0.001 * (lastRequests[i]._tfinish.getTime() - lastRequests[i].trequest.getTime());\n            let downloadBits = 8 * lastRequests[i].trace.reduce((prev, cur) => (prev + cur.b[0]), 0);\n            if (BOLA_DEBUG) msg += ' ' + (0.000001 * downloadBits).toFixed(3) + '/' + downloadSeconds.toFixed(3) + '=' + (0.000001 * downloadBits / downloadSeconds).toFixed(3) + 'Mbps';\n            totalInverse += downloadSeconds / downloadBits;\n        }\n\n        if (BOLA_DEBUG) log('BolaDebug ' + mediaType + ' BolaRule recent throughput = ' + (lastRequests.length / (1000000 * totalInverse)).toFixed(3) + 'Mbps:' + msg);\n\n        return lastRequests.length / totalInverse;\n    }\n\n    function getQualityFromThroughput(bolaState, throughput) {\n        // do not factor in bandwidthSafetyFactor here - it is factored at point of function invocation\n\n        let q = 0;\n\n        bolaState.bitrates.some(function (value, index) {\n            if (value > throughput) {\n                return true;\n            }\n            q = index;\n            return false;\n        });\n\n        return q;\n    }\n\n    function getPlaceholderIncrementInSeconds(metrics, mediaType) {\n        // find out if there was delay because of\n        // 1. lack of availability in live streaming or\n        // 2. bufferLevel > bufferTarget or\n        // 3. fast switching\n\n        let nowMs = Date.now();\n        let lctMs = lastCallTimeDict[mediaType];\n        let wasSwitch = lastFragmentWasSwitchDict[mediaType];\n        let lastRequestFinishMs = NaN;\n\n        lastCallTimeDict[mediaType] = nowMs;\n        lastFragmentWasSwitchDict[mediaType] = false;\n\n        if (!wasSwitch) {\n            let lastRequests = getLastHttpRequests(metrics, 1);\n            if (lastRequests.length > 0) {\n                lastRequestFinishMs = lastRequests[0]._tfinish.getTime();\n                if (lastRequestFinishMs > nowMs) {\n                    // this shouldn't happen, try to handle gracefully\n                    lastRequestFinishMs = nowMs;\n                }\n            }\n        }\n\n        // return the time since the finish of the last request.\n        // The return will be added cumulatively to the placeholder buffer, so we must be sure not to add the same delay twice.\n\n        let delayMs = 0;\n        if (wasSwitch || lctMs > lastRequestFinishMs) {\n            delayMs = nowMs - lctMs;\n        } else {\n            delayMs = nowMs - lastRequestFinishMs;\n        }\n\n        if (isNaN(delayMs) || delayMs <= 0)\n            return 0;\n        return 0.001 * delayMs;\n    }\n\n    function onBufferEmpty() {\n        if (BOLA_DEBUG) log('BolaDebug BUFFER_EMPTY');\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n        eventMediaTypes.forEach(function (mediaType) {\n            let metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n            if (metrics.BolaState.length !== 0) {\n                let bolaState = metrics.BolaState[0]._s;\n                if (bolaState.state === BOLA_STATE_STEADY) {\n                    bolaState.placeholderBuffer = 0;\n                    metricsModel.updateBolaState(mediaType, bolaState);\n                }\n            }\n        });\n    }\n\n    function onPlaybackSeeking(e) {\n        if (BOLA_DEBUG) log('BolaDebug PLAYBACK_SEEKING ' + e.seekTime.toFixed(3));\n        // TODO: 1. Verify what happens if we seek mid-fragment.\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n        eventMediaTypes.forEach(function (mediaType) {\n            let metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n            if (metrics.BolaState.length !== 0) {\n                let bolaState = metrics.BolaState[0]._s;\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                    bolaState.state = BOLA_STATE_STARTUP;\n                }\n                metricsModel.updateBolaState(mediaType, bolaState);\n            }\n        });\n\n        lastFragmentLoadedDict = {};\n        lastFragmentWasSwitchDict = {};\n    }\n\n    function onPeriodSwitchStarted() {\n        // TODO\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            let type = e.chunk.mediaInfo.type;\n            let start = e.chunk.start;\n            if (type !== undefined && !isNaN(start)) {\n                if (start <= lastFragmentLoadedDict[type]) {\n                    lastFragmentWasSwitchDict[type] = true;\n                    // keep lastFragmentLoadedDict[type] e.g. last fragment start 10, switch fragment 8, last is still 10\n                } else {\n                    // isNaN(lastFragmentLoadedDict[type]) also falls here\n                    lastFragmentWasSwitchDict[type] = false;\n                    lastFragmentLoadedDict[type] = start;\n                }\n            }\n        }\n    }\n\n    function getMaxIndex(rulesContext) {\n        const streamProcessor = rulesContext.getStreamProcessor();\n        streamProcessor.getScheduleController().setTimeToLoadDelay(0);\n\n        const switchRequest = SwitchRequest(context).create(SwitchRequest.NO_CHANGE, {name: BolaRule.__dashjs_factory_name});\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = mediaInfo.type;\n        const metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n\n        if (metrics.BolaState.length === 0) {\n            // initialization\n\n            if (BOLA_DEBUG) log('BolaDebug ' + mediaType + '\\nBolaDebug ' + mediaType + ' BolaRule for state=- fragmentStart=' + adapter.getIndexHandlerTime(rulesContext.getStreamProcessor()).toFixed(3));\n\n            let initState = calculateInitialState(rulesContext);\n            metricsModel.updateBolaState(mediaType, initState);\n\n            let q = 0;\n            if (initState.state !== BOLA_STATE_ONE_BITRATE) {\n                // initState.state === BOLA_STATE_STARTUP\n\n                eventMediaTypes.push(mediaType);\n\n                // Bola is not invoked by dash.js to determine the bitrate quality for the first fragment. We might estimate the throughput level here, but the metric related to the HTTP request for the first fragment is usually not available.\n                // TODO: at some point, we may want to consider a tweak that redownloads the first fragment at a higher quality\n\n                let initThroughput = getRecentThroughput(metrics, initState.throughputCount, mediaType);\n                if (initThroughput === 0) {\n                    // We don't have information about any download yet - let someone else decide quality.\n                    if (BOLA_DEBUG) log('BolaDebug ' + mediaType + ' BolaRule quality unchanged for INITIALIZE');\n                    return switchRequest;\n                }\n                q = getQualityFromThroughput(initState, initThroughput * initState.bandwidthSafetyFactor);\n                initState.lastQuality = q;\n                switchRequest.value = q;\n                switchRequest.reason.state = initState.state;\n                switchRequest.reason.throughput = initThroughput;\n            }\n\n            if (BOLA_DEBUG) log('BolaDebug ' + mediaType + ' BolaRule quality ' + q + ' for INITIALIZE');\n            return switchRequest;\n        } // initialization\n\n        // metrics.BolaState.length > 0\n        let bolaState = metrics.BolaState[0]._s;\n        // TODO: does changing bolaState conform to coding style, or should we clone?\n\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n            if (BOLA_DEBUG) log('BolaDebug ' + mediaType + ' BolaRule quality 0 for ONE_BITRATE');\n            return switchRequest;\n        }\n\n        let bitrates = bolaState.bitrates;\n        let utilities = bolaState.utilities;\n\n        if (BOLA_DEBUG) log('BolaDebug ' + mediaType + '\\nBolaDebug ' + mediaType + ' EXECUTE BolaRule for state=' + bolaState.state + ' fragmentStart=' + adapter.getIndexHandlerTime(rulesContext.getStreamProcessor()).toFixed(3));\n\n        let bufferLevel = dashMetrics.getCurrentBufferLevel(metrics) ? dashMetrics.getCurrentBufferLevel(metrics) : 0;\n        let recentThroughput = getRecentThroughput(metrics, bolaState.throughputCount, mediaType);\n\n        if (bufferLevel <= 0.1) {\n            // rebuffering occurred, reset placeholder buffer\n            bolaState.placeholderBuffer = 0;\n        }\n\n        // find out if there was delay because of lack of availability or because buffer level > bufferTarget or because of fast switching\n        let placeholderInc = getPlaceholderIncrementInSeconds(metrics, mediaType);\n        if (placeholderInc > 0) { // TODO: maybe we should set some positive threshold here\n            bolaState.placeholderBuffer += placeholderInc;\n        }\n        if (bolaState.placeholderBuffer < 0) {\n            bolaState.placeholderBuffer = 0;\n        }\n\n        let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n        let bolaQuality = getQualityFromBufferLevel(bolaState, effectiveBufferLevel);\n\n        if (BOLA_DEBUG) log('BolaDebug ' + mediaType + ' BolaRule bufferLevel=' + bufferLevel.toFixed(3) + '(+' + bolaState.placeholderBuffer.toFixed(3) + '=' + effectiveBufferLevel.toFixed(3) + ') recentThroughput=' + (0.000001 * recentThroughput).toFixed(3) + ' tentativeQuality=' + bolaQuality);\n\n        if (bolaState.state === BOLA_STATE_STARTUP) {\n            // in startup phase, use some throughput estimation\n\n            let q = getQualityFromThroughput(bolaState, recentThroughput * bolaState.bandwidthSafetyFactor);\n\n            if (bufferLevel > bolaState.fragmentDuration / REBUFFER_SAFETY_FACTOR) {\n                // only switch to steady state if we believe we have enough buffer to not trigger quality drop to a safeBitrate\n                bolaState.state = BOLA_STATE_STEADY;\n\n                let wantEffectiveBuffer = 0;\n                for (let i = 0; i < q; ++i) {\n                    // We want minimum effective buffer (bufferLevel + placeholderBuffer) that gives a higher score for q when compared with any other i < q.\n                    // We want\n                    //     (Vp * (utilities[q] + gp) - bufferLevel) / bitrates[q]\n                    // to be >= any score for i < q.\n                    // We get score equality for q and i when:\n                    let b = bolaState.Vp * (bolaState.gp + (bitrates[q] * utilities[i] - bitrates[i] * utilities[q]) / (bitrates[q] - bitrates[i]));\n                    if (b > wantEffectiveBuffer) {\n                        wantEffectiveBuffer = b;\n                    }\n                }\n                if (wantEffectiveBuffer > bufferLevel) {\n                    bolaState.placeholderBuffer = wantEffectiveBuffer - bufferLevel;\n                }\n            }\n\n            if (BOLA_DEBUG) log('BolaDebug ' + mediaType + ' BolaRule quality ' + q + ' for STARTUP');\n            bolaState.lastQuality = q;\n            metricsModel.updateBolaState(mediaType, bolaState);\n            switchRequest.value = q;\n            switchRequest.reason.state = BOLA_STATE_STARTUP;\n            switchRequest.reason.throughput = recentThroughput;\n            return switchRequest;\n        }\n\n        // steady state\n\n        // we want to avoid oscillations\n        // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n        if (bolaQuality > bolaState.lastQuality) {\n            // do not multiply throughput by bandwidthSafetyFactor here: we are not using throughput estimation but capping bitrate to avoid oscillations\n            let q = getQualityFromThroughput(bolaState, recentThroughput);\n            if (bolaQuality > q) {\n                // only intervene if we are trying to *increase* quality to an *unsustainable* level\n\n                if (q < bolaState.lastQuality) {\n                    // we are only avoid oscillations - do not drop below last quality\n                    q = bolaState.lastQuality;\n                }\n                // We are dropping to an encoding bitrate which is a little less than the network bandwidth because bitrate levels are discrete. Quality q might lead to buffer inflation, so we deflate buffer to the level that q gives postive utility. This delay will be added below.\n                bolaQuality = q;\n            }\n        }\n\n        // Try to make sure that we can download a chunk without rebuffering. This is especially important for live streaming.\n        if (recentThroughput > 0) {\n            // We can only perform this check if we have a throughput estimate.\n            let safeBitrate = REBUFFER_SAFETY_FACTOR * recentThroughput * bufferLevel / bolaState.fragmentDuration;\n            while (bolaQuality > 0 && bitrates[bolaQuality] > safeBitrate) {\n                --bolaQuality;\n            }\n        }\n\n        // We do not want to overfill buffer with low quality chunks.\n        // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n        let delaySeconds = 0;\n        let wantBufferLevel = bolaState.Vp * (utilities[bolaQuality] + bolaState.gp);\n        delaySeconds = effectiveBufferLevel - wantBufferLevel;\n        if (delaySeconds > 0) {\n            // First reduce placeholder buffer.\n            // Note that this \"delay\" is the main mechanism of depleting placeholderBuffer - the real buffer is depleted by playback.\n            if (delaySeconds > bolaState.placeholderBuffer) {\n                delaySeconds -= bolaState.placeholderBuffer;\n                bolaState.placeholderBuffer = 0;\n            } else {\n                bolaState.placeholderBuffer -= delaySeconds;\n                delaySeconds = 0;\n            }\n        }\n        if (delaySeconds > 0) {\n            // After depleting all placeholder buffer, set delay.\n            if (bolaQuality === bitrates.length - 1) {\n                // At top quality, allow schedule controller to decide how far to fill buffer.\n                delaySeconds = 0;\n            } else {\n                streamProcessor.getScheduleController().setTimeToLoadDelay(1000 * delaySeconds);\n            }\n        } else {\n            delaySeconds = 0;\n        }\n\n        bolaState.lastQuality = bolaQuality;\n        metricsModel.updateBolaState(mediaType, bolaState);\n\n        switchRequest.value = bolaQuality;\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = recentThroughput;\n        switchRequest.reason.bufferLevel = bufferLevel;\n\n        if (BOLA_DEBUG) log('BolaDebug ' + mediaType + ' BolaRule quality ' + bolaQuality + ' delay=' + delaySeconds.toFixed(3) + ' for STEADY');\n        return switchRequest;\n    }\n\n    function reset() {\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        setup();\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nlet factory = FactoryMaker.getClassFactory(BolaRule);\nfactory.BOLA_STATE_ONE_BITRATE    = BOLA_STATE_ONE_BITRATE;\nfactory.BOLA_STATE_STARTUP        = BOLA_STATE_STARTUP;\nfactory.BOLA_STATE_STEADY         = BOLA_STATE_STEADY;\nfactory.BOLA_DEBUG = BOLA_DEBUG; // TODO: remove\nexport default factory;\n"]}