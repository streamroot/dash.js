{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":[],"mappings":"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","file":"BolaRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\nconst BOLA_STATE_ONE_BITRATE    = 0;\nconst BOLA_STATE_STARTUP        = 1;\nconst BOLA_STATE_STEADY         = 2;\n\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n\n    const context = this.context;\n    const log = Debug(context).getInstance().log;\n    const dashMetrics = config.dashMetrics;\n    const metricsModel = config.metricsModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        bolaStateDict;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    function utilitiesFromBitrates(bitrates) {\n        return bitrates.map(b => Math.log(b));\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\n    }\n\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n        let highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\n\n        if (highestUtilityIndex === 0) {\n            // if highestUtilityIndex === 0, then always use lowest bitrate\n            return null;\n        }\n\n        let bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\n\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n        // giving:\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n        const Vp = MINIMUM_BUFFER_S / gp;\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n        return {gp: gp, Vp: Vp};\n    }\n\n    function getInitialBolaState(rulesContext) {\n        let initialState = {};\n\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        let utilities = utilitiesFromBitrates(bitrates);\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\n        let stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n        if (!params) {\n            // only happens when there is only one bitrate level\n            initialState.state = BOLA_STATE_ONE_BITRATE;\n        } else {\n            initialState.state = BOLA_STATE_STARTUP;\n\n            initialState.bitrates = bitrates;\n            initialState.utilities = utilities;\n            initialState.stableBufferTime = stableBufferTime;\n            initialState.Vp = params.Vp;\n            initialState.gp = params.gp;\n\n            initialState.lastQuality = 0;\n            clearBolaStateOnSeek(initialState);\n        }\n\n        return initialState;\n    }\n\n    function clearBolaStateOnSeek(bolaState) {\n        bolaState.placeholderBuffer = 0;\n        bolaState.mostAdvancedSegmentStart = NaN;\n        bolaState.lastSegmentWasReplacement = false;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentDurationS = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n    }\n\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\n        let stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        if (bolaState.stableBufferTime !== stableBufferTime) {\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n                // correct placeholder buffer using two criteria:\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n\n                let bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\n\n                bolaState.stableBufferTime = stableBufferTime;\n                bolaState.Vp = params.Vp;\n                bolaState.gp = params.gp;\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n            }\n        }\n    }\n\n    function getBolaState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let bolaState = bolaStateDict[mediaType];\n        if (!bolaState) {\n            bolaState = getInitialBolaState(rulesContext);\n            bolaStateDict[mediaType] = bolaState;\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n            checkBolaStateStableBufferTime(bolaState, mediaType);\n        }\n        return bolaState;\n    }\n\n    // The core idea of BOLA.\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\n        const bitrateCount = bolaState.bitrates.length;\n        let quality = NaN;\n        let score = NaN;\n        for (let i = 0; i < bitrateCount; ++i) {\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n            if (isNaN(score) || s >= score) {\n                score = s;\n                quality = i;\n            }\n        }\n        return quality;\n    }\n\n    // maximum buffer level which prefers to download at quality rather than wait\n    function maxBufferLevelForQuality(bolaState, quality) {\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n    }\n\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n    function minBufferLevelForQuality(bolaState, quality) {\n        let qBitrate = bolaState.bitrates[quality];\n        let qUtility = bolaState.utilities[quality];\n\n        let min = 0;\n        for (let i = quality - 1; i >= 0; --i) {\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n                let iBitrate = bolaState.bitrates[i];\n                let iUtility = bolaState.utilities[i];\n\n                let level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n            }\n        }\n        return min;\n    }\n\n    /*\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n     * There are two main reasons we might want to increase the placeholder buffer:\n     *\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n     *\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n     */\n    function updatePlaceholderBuffer(bolaState, mediaType) {\n        let nowMs = Date.now();\n\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n            let delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\n            // no download after last call, compensate for delay between calls\n            let delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        }\n\n        bolaState.lastCallTimeMs = nowMs;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n\n        checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    function onBufferEmpty() {\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n        for (let mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n                bolaStateDict[mediaType].placeholderBuffer = 0;\n            }\n        }\n    }\n\n    function onPlaybackSeeking() {\n        // TODO: 1. Verify what happens if we seek mid-fragment.\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n        for (let mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\n                let bolaState = bolaStateDict[mediaType];\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n                    clearBolaStateOnSeek(bolaState);\n                }\n            }\n        }\n    }\n\n    function onPeriodSwitchStarted() {\n        // TODO: does this have to be handled here?\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            let bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                let start = e.chunk.start;\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n                    bolaState.mostAdvancedSegmentStart = start;\n                    bolaState.lastSegmentWasReplacement = false;\n                } else {\n                    bolaState.lastSegmentWasReplacement = true;\n                }\n\n                bolaState.lastSegmentStart = start;\n                bolaState.lastSegmentDurationS = e.chunk.duration;\n                bolaState.lastQuality = e.chunk.quality;\n\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n            }\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            let bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n                checkNewSegment(bolaState, e.mediaType);\n            }\n        }\n    }\n\n    /*\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n     * decides not to increase the quality to avoid oscillations.\n     *\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n     * We avoid this by growing the placeholder buffer.\n     */\n    function checkNewSegment(bolaState, mediaType) {\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\n\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n                let bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\n                let bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n                let maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n                let maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n            }\n\n            // then see if we should grow placeholder buffer\n\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n                // compensate for segments that were downloaded but did not grow the buffer\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n            }\n\n            bolaState.lastSegmentStart = NaN;\n            bolaState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e && !isNaN(e.newQuality)) {\n            let bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\n                let bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(e.mediaType));\n                let wantEffectiveBufferLevel;\n                if (e.newQuality === 0) {\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n                } else {\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, e.newQuality);\n                }\n                bolaState.placeholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n            }\n        }\n    }\n\n    function getMaxIndex(rulesContext) {\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n        const streamProcessor = rulesContext.getStreamProcessor();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const streamId = streamInfo ? streamInfo.id : null;\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n        const switchRequest = SwitchRequest(context).create();\n        switchRequest.reason = switchRequest.reason || {};\n\n        if (!useBufferOccupancyABR) {\n            return switchRequest;\n        }\n\n        streamProcessor.getScheduleController().setTimeToLoadDelay(0);\n\n        let bolaState = getBolaState(rulesContext);\n\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            log('BOLA ABR rule invoked for media type \\'' + mediaType + '\\' with only one bitrate.');\n            return switchRequest;\n        }\n\n        let bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);\n        let throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n        let safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        let latency = throughputHistory.getAverageLatency(mediaType);\n        let quality;\n\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (bolaState.state) {\n            case BOLA_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n                bolaState.lastQuality = quality;\n\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n                    bolaState.state = BOLA_STATE_STEADY;\n                }\n\n                break; // BOLA_STATE_STARTUP\n\n            case BOLA_STATE_STEADY:\n\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n                //     However, the InsufficientBufferRule takes care of this scenario.\n\n                updatePlaceholderBuffer(bolaState, mediaType);\n\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\n\n                // we want to avoid oscillations\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n                let qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\n                    // we are only avoid oscillations - do not drop below last quality\n\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n                }\n\n                // We do not want to overfill buffer with low quality chunks.\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\n\n                // First reduce placeholder buffer, then tell schedule controller to pause.\n                if (delayS <= bolaState.placeholderBuffer) {\n                    bolaState.placeholderBuffer -= delayS;\n                    delayS = 0;\n                } else {\n                    delayS -= bolaState.placeholderBuffer;\n                    bolaState.placeholderBuffer = 0;\n\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\n                        streamProcessor.getScheduleController().setTimeToLoadDelay(1000 * delayS);\n                    } else {\n                        delayS = 0;\n                    }\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n                switchRequest.reason.delay = delayS;\n\n                bolaState.lastQuality = quality;\n                // keep bolaState.state === BOLA_STATE_STEADY\n\n                break; // BOLA_STATE_STEADY\n\n            default:\n                log('BOLA ABR rule invoked in bad state.');\n                // should not arrive here, try to recover\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = bolaState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                bolaState.state = BOLA_STATE_STARTUP;\n                clearBolaStateOnSeek(bolaState);\n        }\n\n        return switchRequest;\n    }\n\n    function resetInitialSettings() {\n        bolaStateDict = {};\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexport default FactoryMaker.getClassFactory(BolaRule);\n"]}