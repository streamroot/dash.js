{"version":3,"sources":["../../../../src/streaming/MediaPlayerEvents.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oCA8BuB,2BAA2B;;;;;;;;;IAK5C,iBAAiB;YAAjB,iBAAiB;;;;;;AAKP,WALV,iBAAiB,GAKJ;0BALb,iBAAiB;;AAMf,+BANF,iBAAiB,6CAMP;;;;;;AAMR,QAAI,CAAC,aAAa,GAAG,aAAa,CAAC;;;;;;AAMnC,QAAI,CAAC,YAAY,GAAG,eAAe,CAAC;;;;;;AAMpC,QAAI,CAAC,aAAa,GAAG,cAAc,CAAC;;;;;;AAMpC,QAAI,CAAC,0BAA0B,GAAG,oBAAoB,CAAC;;;;;;AAMvD,QAAI,CAAC,KAAK,GAAG,OAAO,CAAC;;;;;;AAMrB,QAAI,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;;;;;AAK7D,QAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;;;;;AAKzD,QAAI,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;;;;;AAK7D,QAAI,CAAC,GAAG,GAAG,KAAK,CAAC;;;;;;AAMjB,QAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;;;AAKxC,QAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;;;AAKxC,QAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;;;AAKtC,QAAI,CAAC,YAAY,GAAG,aAAa,CAAC;;;;;AAKlC,QAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;;;AAKtC,QAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;;;;;AAKvD,QAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;;;;;;AAMnD,QAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;;;;;;AAMzD,QAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;;;;;;AAMvD,QAAI,CAAC,kBAAkB,GAAG,mBAAmB,CAAC;;;;;AAK9C,QAAI,CAAC,iBAAiB,GAAG,oBAAoB,CAAC;;;;;AAK9C,QAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;;;;;;;;AAQzC,QAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;;;;;;AAM1B,QAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;;;;;AAOtC,QAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;;;AAKtC,QAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;;;;;;AAMjD,QAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;;;;;AAKzD,QAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;;;;;AAOxC,QAAI,CAAC,gBAAgB,GAAG,iBAAiB,CAAC;;;;;;;AAO1C,QAAI,CAAC,iBAAiB,GAAG,kBAAkB,CAAC;;;;;AAK5C,QAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;;;;;AAKnD,QAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;;;AAKxC,QAAI,CAAC,gBAAgB,GAAG,iBAAiB,CAAC;;;;;;;AAO1C,QAAI,CAAC,gBAAgB,GAAG,iBAAiB,CAAC;;;;;AAK1C,QAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;GACtD;;SAxMC,iBAAiB;;;AA2MvB,IAAI,iBAAiB,GAAG,IAAI,iBAAiB,EAAE,CAAC;qBACjC,iBAAiB","file":"MediaPlayerEvents.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventsBase from '../core/events/EventsBase';\n/**\n * @class\n *\n */\nclass MediaPlayerEvents extends EventsBase {\n\n    /**\n     * @description Public facing external events to be used when developing a player that implements dash.js.\n     */\n    constructor () {\n        super();\n        /**\n         * Triggered when playback will not start yet\n         * as the MPD's availabilityStartTime is in the future.\n         * Check delay property in payload to determine time before playback will start.\n         */\n        this.AST_IN_FUTURE = 'astInFuture';\n        /**\n         * Triggered when the video element's buffer state changes to stalled.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_EMPTY\n         */\n        this.BUFFER_EMPTY = 'bufferStalled';\n        /**\n         * Triggered when the video element's buffer state changes to loaded.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_LOADED\n         */\n        this.BUFFER_LOADED = 'bufferLoaded';\n\n        /**\n         * Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state.\n         * @event MediaPlayerEvents#BUFFER_LEVEL_STATE_CHANGED\n         */\n        this.BUFFER_LEVEL_STATE_CHANGED = 'bufferStateChanged';\n\n        /**\n        * Triggered when there is an error from the element or MSE source buffer.\n        * @event MediaPlayerEvents#ERROR\n        */\n        this.ERROR = 'error';\n\n        /**\n        * Triggered when a fragment download has completed.\n        * @event MediaPlayerEvents#FRAGMENT_LOADING_COMPLETED\n        */\n        this.FRAGMENT_LOADING_COMPLETED = 'fragmentLoadingCompleted';\n        /**\n        * Triggered when a fragment download has started.\n        * @event MediaPlayerEvents#FRAGMENT_LOADING_STARTED\n        */\n        this.FRAGMENT_LOADING_STARTED = 'fragmentLoadingStarted';\n        /**\n        * Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule..\n        * @event MediaPlayerEvents#FRAGMENT_LOADING_ABANDONED\n        */\n        this.FRAGMENT_LOADING_ABANDONED = 'fragmentLoadingAbandoned';\n        /**\n         * Triggered when {@link module:Debug} log method is called.\n         * @event MediaPlayerEvents#LOG\n         */\n        this.LOG = 'log';\n        //TODO refactor with internal event\n        /**\n         * Triggered when the manifest load is complete\n         * @event MediaPlayerEvents#MANIFEST_LOADED\n         */\n        this.MANIFEST_LOADED = 'manifestLoaded';\n        /**\n         * Triggered anytime there is a change to the overall metrics.\n         * @event MediaPlayerEvents#METRICS_CHANGED\n         */\n        this.METRICS_CHANGED = 'metricsChanged';\n        /**\n         * Triggered when an individual metric is added, updated or cleared.\n         * @event MediaPlayerEvents#METRIC_CHANGED\n         */\n        this.METRIC_CHANGED = 'metricChanged';\n        /**\n         * Triggered every time a new metric is added.\n         * @event MediaPlayerEvents#METRIC_ADDED\n         */\n        this.METRIC_ADDED = 'metricAdded';\n        /**\n         * Triggered every time a metric is updated.\n         * @event MediaPlayerEvents#METRIC_UPDATED\n         */\n        this.METRIC_UPDATED = 'metricUpdated';\n        /**\n         * Triggered at the stream end of a period.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_COMPLETED\n         */\n        this.PERIOD_SWITCH_COMPLETED = 'periodSwitchCompleted';\n        /**\n         * Triggered when a new period starts.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_STARTED\n         */\n        this.PERIOD_SWITCH_STARTED = 'periodSwitchStarted';\n\n        /**\n         * Triggered when an ABR up /down switch is initialed; either by user in manual mode or auto mode via ABR rules.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_REQUESTED\n         */\n        this.QUALITY_CHANGE_REQUESTED = 'qualityChangeRequested';\n\n        /**\n         * Triggered when the new ABR quality is being rendered on-screen.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_RENDERED\n         */\n        this.QUALITY_CHANGE_RENDERED = 'qualityChangeRendered';\n\n        /**\n         * Triggered when the stream is setup and ready.\n         * @event MediaPlayerEvents#STREAM_INITIALIZED\n         */\n        this.STREAM_INITIALIZED = 'streamInitialized';\n        /**\n         * Triggered once all text tracks detected in the MPD are added to the video element.\n         * @event MediaPlayerEvents#TEXT_TRACKS_ADDED\n         */\n        this.TEXT_TRACKS_ADDED = 'allTextTracksAdded';\n        /**\n         * Triggered when a text track is added to the video element's TextTrackList\n         * @event MediaPlayerEvents#TEXT_TRACK_ADDED\n         */\n        this.TEXT_TRACK_ADDED = 'textTrackAdded';\n\n        /**\n         * Sent when enough data is available that the media can be played,\n         * at least for a couple of frames.  This corresponds to the\n         * HAVE_ENOUGH_DATA readyState.\n         * @event MediaPlayerEvents#CAN_PLAY\n         */\n        this.CAN_PLAY = 'canPlay';\n\n        /**\n         * Sent when playback completes.\n         * @event MediaPlayerEvents#PLAYBACK_ENDED\n         */\n        this.PLAYBACK_ENDED = 'playbackEnded';\n\n        /**\n         * Sent when an error occurs.  The element's error\n         * attribute contains more information.\n         * @event MediaPlayerEvents#PLAYBACK_ERROR\n         */\n        this.PLAYBACK_ERROR = 'playbackError';\n        /**\n         * Sent when playback is not allowed (for example if user gesture is needed).\n         * @event MediaPlayerEvents#PLAYBACK_NOT_ALLOWED\n         */\n        this.PLAYBACK_NOT_ALLOWED = 'playbackNotAllowed';\n        /**\n         * The media's metadata has finished loading; all attributes now\n         * contain as much useful information as they're going to.\n         * @event MediaPlayerEvents#PLAYBACK_METADATA_LOADED\n         */\n        this.PLAYBACK_METADATA_LOADED = 'playbackMetaDataLoaded';\n        /**\n         * Sent when playback is paused.\n         * @event MediaPlayerEvents#PLAYBACK_PAUSED\n         */\n        this.PLAYBACK_PAUSED = 'playbackPaused';\n        /**\n         * Sent when the media begins to play (either for the first time, after having been paused,\n         * or after ending and then restarting).\n         *\n         * @event MediaPlayerEvents#PLAYBACK_PLAYING\n         */\n        this.PLAYBACK_PLAYING = 'playbackPlaying';\n        /**\n         * Sent periodically to inform interested parties of progress downloading\n         * the media. Information about the current amount of the media that has\n         * been downloaded is available in the media element's buffered attribute.\n         * @event MediaPlayerEvents#PLAYBACK_PROGRESS\n         */\n        this.PLAYBACK_PROGRESS = 'playbackProgress';\n        /**\n         * Sent when the playback speed changes.\n         * @event MediaPlayerEvents#PLAYBACK_RATE_CHANGED\n         */\n        this.PLAYBACK_RATE_CHANGED = 'playbackRateChanged';\n        /**\n         * Sent when a seek operation completes.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKED\n         */\n        this.PLAYBACK_SEEKED = 'playbackSeeked';\n        /**\n         * Sent when a seek operation begins.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKING\n         */\n        this.PLAYBACK_SEEKING = 'playbackSeeking';\n        /**\n         * Sent when playback of the media starts after having been paused;\n         * that is, when playback is resumed after a prior pause event.\n         *\n         * @event MediaPlayerEvents#PLAYBACK_STARTED\n         */\n        this.PLAYBACK_STARTED = 'playbackStarted';\n        /**\n         * The time indicated by the element's currentTime attribute has changed.\n         * @event MediaPlayerEvents#PLAYBACK_TIME_UPDATED\n         */\n        this.PLAYBACK_TIME_UPDATED = 'playbackTimeUpdated';\n    }\n}\n\nlet mediaPlayerEvents = new MediaPlayerEvents();\nexport default mediaPlayerEvents;\n"]}