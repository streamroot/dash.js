{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":[],"mappings":"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","file":"TimeSyncController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Error from './../vo/Error';\nimport EventBus from './../../core/EventBus';\nimport Events from './../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst TIME_SYNC_FAILED_ERROR_CODE = 1;\nconst HTTP_TIMEOUT_MS = 5000;\n\nfunction TimeSyncController() {\n\n    let context = this.context;\n    let log = Debug(context).getInstance().log;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        offsetToDeviceTimeMs,\n        isSynchronizing,\n        isInitialised,\n        useManifestDateHeaderTimeSource,\n        handlers,\n        metricsModel,\n        dashMetrics;\n\n    function initialize(timingSources, useManifestDateHeader) {\n        useManifestDateHeaderTimeSource = useManifestDateHeader;\n        offsetToDeviceTimeMs = 0;\n        isSynchronizing = false;\n        isInitialised = false;\n\n        // a list of known schemeIdUris and a method to call with @value\n        handlers = {\n            'urn:mpeg:dash:utc:http-head:2014':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2014':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2014':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2014':        directHandler,\n\n            // some specs referencing early ISO23009-1 drafts incorrectly use\n            // 2012 in the URI, rather than 2014. support these for now.\n            'urn:mpeg:dash:utc:http-head:2012':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2012':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2012':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2012':        directHandler,\n\n            // it isn't clear how the data returned would be formatted, and\n            // no public examples available so http-ntp not supported for now.\n            // presumably you would do an arraybuffer type xhr and decode the\n            // binary data returned but I would want to see a sample first.\n            'urn:mpeg:dash:utc:http-ntp:2014':      notSupportedHandler,\n\n            // not clear how this would be supported in javascript (in browser)\n            'urn:mpeg:dash:utc:ntp:2014':           notSupportedHandler,\n            'urn:mpeg:dash:utc:sntp:2014':          notSupportedHandler\n        };\n\n        if (!getIsSynchronizing()) {\n            attemptSync(timingSources);\n            setIsInitialised(true);\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.metricsModel) {\n            metricsModel = config.metricsModel;\n        }\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n    }\n\n    function getOffsetToDeviceTimeMs() {\n        return getOffsetMs();\n    }\n\n    function setIsSynchronizing(value) {\n        isSynchronizing = value;\n    }\n\n    function getIsSynchronizing() {\n        return isSynchronizing;\n    }\n\n    function setIsInitialised(value) {\n        isInitialised = value;\n    }\n\n    function setOffsetMs(value) {\n        offsetToDeviceTimeMs = value;\n    }\n\n    function getOffsetMs() {\n        return offsetToDeviceTimeMs;\n    }\n\n    // takes xsdatetime and returns milliseconds since UNIX epoch\n    // may not be necessary as xsdatetime is very similar to ISO 8601\n    // which is natively understood by javascript Date parser\n    function alternateXsdatetimeDecoder(xsdatetimeStr) {\n        // taken from DashParser - should probably refactor both uses\n        var SECONDS_IN_MIN = 60;\n        var MINUTES_IN_HOUR = 60;\n        var MILLISECONDS_IN_SECONDS = 1000;\n        var datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n\n        var utcDate,\n            timezoneOffset;\n\n        var match = datetimeRegex.exec(xsdatetimeStr);\n\n        // If the string does not contain a timezone offset different browsers can interpret it either\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n        // all browsers\n        utcDate = Date.UTC(\n            parseInt(match[1], 10),\n            parseInt(match[2], 10) - 1, // months start from zero\n            parseInt(match[3], 10),\n            parseInt(match[4], 10),\n            parseInt(match[5], 10),\n            (match[6] && (parseInt(match[6], 10) || 0)),\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\n        );\n        // If the date has timezone offset take it into account as well\n        if (match[9] && match[10]) {\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n        }\n\n        return new Date(utcDate).getTime();\n    }\n\n    // try to use the built in parser, since xsdate is a constrained ISO8601\n    // which is supported natively by Date.parse. if that fails, try a\n    // regex-based version used elsewhere in this application.\n    function xsdatetimeDecoder(xsdatetimeStr) {\n        var parsedDate = Date.parse(xsdatetimeStr);\n\n        if (isNaN(parsedDate)) {\n            parsedDate = alternateXsdatetimeDecoder(xsdatetimeStr);\n        }\n\n        return parsedDate;\n    }\n\n    // takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n    function iso8601Decoder(isoStr) {\n        return Date.parse(isoStr);\n    }\n\n    // takes RFC 1123 timestamp (which is same as ISO8601) and returns\n    // milliseconds since UNIX epoch\n    function rfc1123Decoder(dateStr) {\n        return Date.parse(dateStr);\n    }\n\n    function notSupportedHandler(url, onSuccessCB, onFailureCB) {\n        onFailureCB();\n    }\n\n    function directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n        var time = xsdatetimeDecoder(xsdatetimeStr);\n\n        if (!isNaN(time)) {\n            onSuccessCB(time);\n            return;\n        }\n\n        onFailureCB();\n    }\n\n    function httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n        var oncomplete,\n            onload;\n        var complete = false;\n        var req = new XMLHttpRequest();\n\n        var verb = isHeadRequest ? 'HEAD' : 'GET';\n        var urls = url.match(/\\S+/g);\n\n        // according to ISO 23009-1, url could be a white-space\n        // separated list of URLs. just handle one at a time.\n        url = urls.shift();\n\n        oncomplete = function () {\n            if (complete) {\n                return;\n            }\n\n            // we only want to pass through here once per xhr,\n            // regardless of whether the load was successful.\n            complete = true;\n\n            // if there are more urls to try, call self.\n            if (urls.length) {\n                httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n            } else {\n                onFailureCB();\n            }\n        };\n\n        onload = function () {\n            var time,\n                result;\n\n            if (req.status === 200) {\n                time = isHeadRequest ?\n                        req.getResponseHeader('Date') :\n                        req.response;\n\n                result = decoder(time);\n\n                // decoder returns NaN if non-standard input\n                if (!isNaN(result)) {\n                    onSuccessCB(result);\n                    complete = true;\n                }\n            }\n        };\n\n        req.open(verb, url);\n        req.timeout = HTTP_TIMEOUT_MS || 0;\n        req.onload = onload;\n        req.onloadend = oncomplete;\n        req.send();\n    }\n\n    function httpHeadHandler(url, onSuccessCB, onFailureCB) {\n        httpHandler(rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n    }\n\n    function checkForDateHeader() {\n        var metrics = metricsModel.getReadOnlyMetricsFor('stream');\n        var dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID(metrics, 'Date');\n        var dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n        if (!isNaN(dateHeaderTime)) {\n            setOffsetMs(dateHeaderTime - new Date().getTime());\n            completeTimeSyncSequence(false, dateHeaderTime / 1000, offsetToDeviceTimeMs);\n        }else {\n            completeTimeSyncSequence(true);\n        }\n    }\n\n    function completeTimeSyncSequence(failed, time, offset) {\n        setIsSynchronizing(false);\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED, { time: time, offset: offset, error: failed ? new Error(TIME_SYNC_FAILED_ERROR_CODE) : null });\n    }\n\n    function attemptSync(sources, sourceIndex) {\n\n        // if called with no sourceIndex, use zero (highest priority)\n        var  index = sourceIndex || 0;\n\n        // the sources should be ordered in priority from the manifest.\n        // try each in turn, from the top, until either something\n        // sensible happens, or we run out of sources to try.\n        var source = sources[index];\n\n        // callback to emit event to listeners\n        var onComplete = function (time, offset) {\n            var failed = !time || !offset;\n            if (failed && useManifestDateHeaderTimeSource) {\n                //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n                checkForDateHeader();\n            } else {\n                completeTimeSyncSequence(failed, time, offset);\n            }\n        };\n\n        setIsSynchronizing(true);\n\n        if (source) {\n            // check if there is a handler for this @schemeIdUri\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\n                // if so, call it with its @value\n                handlers[source.schemeIdUri](\n                    source.value,\n                    function (serverTime) {\n                        // the timing source returned something useful\n                        var deviceTime = new Date().getTime();\n                        var offset = serverTime - deviceTime;\n\n                        setOffsetMs(offset);\n\n                        log('Local time:      ' + new Date(deviceTime));\n                        log('Server time:     ' + new Date(serverTime));\n                        log('Difference (ms): ' + offset);\n\n                        onComplete(serverTime, offset);\n                    },\n                    function () {\n                        // the timing source was probably uncontactable\n                        // or returned something we can't use - try again\n                        // with the remaining sources\n                        attemptSync(sources, index + 1);\n                    }\n                );\n            } else {\n                // an unknown schemeIdUri must have been found\n                // try again with the remaining sources\n                attemptSync(sources, index + 1);\n            }\n        } else {\n            // no valid time source could be found, just use device time\n            setOffsetMs(0);\n            onComplete();\n        }\n    }\n\n    function reset() {\n        setIsInitialised(false);\n        setIsSynchronizing(false);\n    }\n\n    instance = {\n        initialize: initialize,\n        getOffsetToDeviceTimeMs: getOffsetToDeviceTimeMs,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\nlet factory = FactoryMaker.getSingletonFactory(TimeSyncController);\nfactory.TIME_SYNC_FAILED_ERROR_CODE = TIME_SYNC_FAILED_ERROR_CODE;\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\nexport default factory;"]}