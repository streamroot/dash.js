{"version":3,"sources":["../../../../../src/streaming/controllers/SourceBufferController.js"],"names":[],"mappings":"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","file":"SourceBufferController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashJSError from '../vo/DashJSError';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nconst QUOTA_EXCEEDED_ERROR_CODE = 22;\n\nfunction SourceBufferController(config) {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n    let textController = config.textController;\n\n    let instance;\n\n    function createSourceBuffer(mediaSource, mediaInfo) {\n\n        let codec = mediaInfo.codec;\n        let buffer = null;\n\n        try {\n            // Safari claims to support anything starting 'application/mp4'.\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n            // - currently no browser does, so check for it and use our own\n            // implementation. The same is true for codecs=\"wvtt\".\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n                throw new Error('not really supported');\n            }\n\n            buffer = mediaSource.addSourceBuffer(codec);\n\n        } catch (ex) {\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\n                buffer = textController.getTextSourceBuffer();\n            } else {\n                throw ex;\n            }\n        }\n\n        return buffer;\n    }\n\n    function removeSourceBuffer(mediaSource, buffer) {\n        try {\n            mediaSource.removeSourceBuffer(buffer);\n        } catch (ex) {}\n    }\n\n    function getBufferRange(buffer, time, tolerance) {\n        let ranges = null;\n        let start = 0;\n        let end = 0;\n        let firstStart = null;\n        let lastEnd = null;\n        let gap = 0;\n\n        let len,\n            i;\n\n        let toler = (tolerance || 0.15);\n\n        try {\n            ranges = buffer.buffered;\n        } catch (ex) {\n            return null;\n        }\n\n        if (ranges !== null && ranges !== undefined) {\n            for (i = 0, len = ranges.length; i < len; i++) {\n                start = ranges.start(i);\n                end = ranges.end(i);\n                if (firstStart === null) {\n                    gap = Math.abs(start - time);\n                    if (time >= start && time < end) {\n                        // start the range\n                        firstStart = start;\n                        lastEnd = end;\n                    } else if (gap <= toler) {\n                        // start the range even though the buffer does not contain time 0\n                        firstStart = start;\n                        lastEnd = end;\n                    }\n                } else {\n                    gap = start - lastEnd;\n                    if (gap <= toler) {\n                        // the discontinuity is smaller than the tolerance, combine the ranges\n                        lastEnd = end;\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            if (firstStart !== null) {\n                return {\n                    start: firstStart,\n                    end: lastEnd\n                };\n            }\n        }\n\n        return null;\n    }\n\n    function getAllRanges(buffer) {\n        let ranges = null;\n\n        try {\n            ranges = buffer.buffered;\n            return ranges;\n        } catch (ex) {\n            return null;\n        }\n    }\n\n    function getTotalBufferedTime(buffer) {\n        let ranges = getAllRanges(buffer);\n        let totalBufferedTime = 0;\n        let ln,\n            i;\n\n        if (!ranges) return totalBufferedTime;\n\n        for (i = 0, ln = ranges.length; i < ln; i++) {\n            totalBufferedTime += ranges.end(i) - ranges.start(i);\n        }\n\n        return totalBufferedTime;\n    }\n\n    function getBufferLength(buffer, time, tolerance) {\n\n        let range,\n            length;\n\n        range = getBufferRange(buffer, time, tolerance);\n\n        if (range === null) {\n            length = 0;\n        } else {\n            length = range.end - time;\n        }\n\n        return length;\n    }\n\n    function getRangeDifference(currentRanges, buffer) {\n        if (!buffer) return null;\n\n        //TODO we may need to look for a more elegant and robust method\n        // The logic below checks that is the difference between currentRanges and actual SourceBuffer ranges\n\n        let newRanges = getAllRanges(buffer);\n        let newStart,\n            newEnd,\n            equalStart,\n            equalEnd,\n            currentRange,\n            nextCurrentRange,\n            nextNewRange,\n            hasRange,\n            diff;\n\n        if (!newRanges) return null;\n\n        for (let i = 0, ln = newRanges.length; i < ln; i++) {\n            hasRange = currentRanges.length > i;\n            currentRange = hasRange ? {\n                start: currentRanges.start(i),\n                end: currentRanges.end(i)\n            } : null;\n            newStart = newRanges.start(i);\n            newEnd = newRanges.end(i);\n\n            // if there is no range with the same index it means that a new range has been added. This range is\n            // the difference we are looking for\n            // Example\n            // current ranges\n            // 0|---range1---|4  8|--range2--|12\n            // new ranges\n            // 0|---range1---|4| 8|--range2--|12  16|--range3--|20\n\n            if (!currentRange) {\n                diff = {\n                    start: newStart,\n                    end: newEnd\n                };\n                return diff;\n            }\n\n            equalStart = currentRange.start === newStart;\n            equalEnd = currentRange.end === newEnd;\n\n            // if ranges are equal do nothing here and go the next ranges\n            if (equalStart && equalEnd) continue;\n\n            // start or/and end of the range has been changed\n            if (equalStart) {\n                diff = {\n                    start: currentRange.end,\n                    end: newEnd\n                };\n            } else if (equalEnd) {\n                diff = {\n                    start: newStart,\n                    end: currentRange.start\n                };\n            } else {\n                // new range has been added before the current one\n                diff = {\n                    start: newStart,\n                    end: newEnd\n                };\n                return diff;\n            }\n\n            // if there is next current range but no next new range (it it is not equal the next current range) it means\n            // that the ranges have been merged\n            // Example 1\n            // current ranges\n            // 0|---range1---|4  8|--range2--|12  16|---range3---|\n            // new ranges\n            // 0|-----------range1-----------|12  16|---range3--|\n            nextCurrentRange = currentRanges.length > (i + 1) ? {\n                start: currentRanges.start(i + 1),\n                end: currentRanges.end(i + 1)\n            } : null;\n            nextNewRange = (i + 1) < ln ? {\n                start: newRanges.start(i + 1),\n                end: newRanges.end(i + 1)\n            } : null;\n\n            if (nextCurrentRange && (!nextNewRange || (nextNewRange.start !== nextCurrentRange.start || nextNewRange.end !== nextCurrentRange.end))) {\n                diff.end = nextCurrentRange.start;\n            }\n\n            return diff;\n        }\n\n        return null;\n    }\n\n    function append(buffer, chunk) {\n        let bytes = chunk.bytes;\n        let appendMethod = ('append' in buffer) ? 'append' : (('appendBuffer' in buffer) ? 'appendBuffer' : null);\n        // our user-defined sourcebuffer-like object has Object as its\n        // prototype whereas built-in SourceBuffers will have something\n        // more sensible. do not pass chunk to built-in append.\n        let acceptsChunk = Object.prototype.toString.call(buffer).slice(8, -1) === 'Object';\n\n        if (!appendMethod) return;\n\n        waitForUpdateEnd(buffer, function () {\n            try {\n                if (acceptsChunk) {\n                    // chunk.start is used in calculations by TextSourceBuffer\n                    buffer[appendMethod](bytes, chunk);\n                } else {\n                    buffer[appendMethod](bytes);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(buffer, function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_APPEND_COMPLETED, {\n                        buffer: buffer,\n                        bytes: bytes\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_APPEND_COMPLETED, {\n                    buffer: buffer,\n                    bytes: bytes,\n                    error: new DashJSError(err.code, err.message, null)\n                });\n            }\n        });\n    }\n\n    function remove(buffer, start, end, mediaSource) {\n\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n        waitForUpdateEnd(buffer, function () {\n            try {\n                if ((start >= 0) && (end > start) && (mediaSource.readyState !== 'ended')) {\n                    buffer.remove(start, end);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(buffer, function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                        buffer: buffer,\n                        from: start,\n                        to: end\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                    buffer: buffer,\n                    from: start,\n                    to: end,\n                    error: new DashJSError(err.code, err.message, null)\n                });\n            }\n        });\n    }\n\n    function abort(mediaSource, buffer) {\n        try {\n            if (mediaSource.readyState === 'open') {\n                buffer.abort();\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n            }\n        } catch (ex) {}\n    }\n\n    function waitForUpdateEnd(buffer, callback) {\n        let intervalId;\n        const CHECK_INTERVAL = 50;\n\n        const checkIsUpdateEnded = function () {\n            // if updating is still in progress do nothing and wait for the next check again.\n            if (buffer.updating) return;\n            // updating is completed, now we can stop checking and resolve the promise\n            clearInterval(intervalId);\n            callback();\n        };\n\n        const updateEndHandler = function () {\n            if (buffer.updating) return;\n\n            buffer.removeEventListener('updateend', updateEndHandler, false);\n            callback();\n        };\n\n        if (!buffer.updating) {\n            callback();\n            return;\n        }\n\n        // use updateend event if possible\n        if (typeof buffer.addEventListener === 'function') {\n            try {\n                buffer.addEventListener('updateend', updateEndHandler, false);\n            } catch (err) {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } else {\n            // use setInterval to periodically check if updating has been completed\n            intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n        }\n    }\n\n    instance = {\n        append: append,\n        remove: remove,\n        abort: abort,\n        createSourceBuffer: createSourceBuffer,\n        removeSourceBuffer: removeSourceBuffer,\n        getBufferRange: getBufferRange,\n        getAllRanges: getAllRanges,\n        getTotalBufferedTime: getTotalBufferedTime,\n        getBufferLength: getBufferLength,\n        getRangeDifference: getRangeDifference\n    };\n\n    return instance;\n}\n\nSourceBufferController.__dashjs_factory_name = 'SourceBufferController';\nlet factory = FactoryMaker.getSingletonFactory(SourceBufferController);\nfactory.QUOTA_EXCEEDED_ERROR_CODE = QUOTA_EXCEEDED_ERROR_CODE;\nFactoryMaker.updateSingletonFactory(SourceBufferController.__dashjs_factory_name, factory);\nexport default factory;\n"]}