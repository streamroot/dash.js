{"version":3,"sources":["../../../../../src/streaming/controllers/BufferController.js"],"names":[],"mappings":"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","file":"BufferController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FragmentModel from '../models/FragmentModel';\nimport MediaPlayerModel from '../models/MediaPlayerModel';\nimport SourceBufferController from './SourceBufferController';\nimport AbrController from './AbrController';\nimport PlaybackController from './PlaybackController';\nimport MediaController from './MediaController';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport BoxParser from '../utils/BoxParser';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport InitCache from '../utils/InitCache';\n\nconst BUFFER_LOADED = 'bufferLoaded';\nconst BUFFER_EMPTY = 'bufferStalled';\nconst STALL_THRESHOLD = 0.5;\n\nfunction BufferController(config) {\n\n    const context = this.context;\n    const log = Debug(context).getInstance().log;\n    const eventBus = EventBus(context).getInstance();\n    const metricsModel = config.metricsModel;\n    const manifestModel = config.manifestModel;\n    const sourceBufferController = config.sourceBufferController;\n    const errHandler = config.errHandler;\n    const streamController = config.streamController;\n    const mediaController = config.mediaController;\n    const adapter = config.adapter;\n    const textSourceBuffer = config.textSourceBuffer;\n\n\n    let instance,\n        requiredQuality,\n        isBufferingCompleted,\n        bufferLevel,\n        criticalBufferLevel,\n        mediaSource,\n        maxAppendedIndex,\n        lastIndex,\n        type,\n        buffer,\n        bufferState,\n        appendedBytesInfo,\n        wallclockTicked,\n        appendingMediaChunk,\n        isAppendingInProgress,\n        isPruningInProgress,\n        inbandEventFound,\n        playbackController,\n        streamProcessor,\n        abrController,\n        scheduleController,\n        mediaPlayerModel,\n        initCache;\n\n    function setup() {\n        requiredQuality = AbrController.QUALITY_DEFAULT;\n        isBufferingCompleted = false;\n        bufferLevel = 0;\n        criticalBufferLevel = Number.POSITIVE_INFINITY;\n        maxAppendedIndex = 0;\n        lastIndex = Number.POSITIVE_INFINITY;\n        buffer = null;\n        bufferState = BUFFER_EMPTY;\n        wallclockTicked = 0;\n        appendingMediaChunk = false;\n        isAppendingInProgress = false;\n        isPruningInProgress = false;\n        inbandEventFound = false;\n    }\n\n    function initialize(Type, Source, StreamProcessor) {\n        type = Type;\n        setMediaSource(Source);\n        streamProcessor = StreamProcessor;\n        mediaPlayerModel = MediaPlayerModel(context).getInstance();\n        playbackController = PlaybackController(context).getInstance();\n        abrController = AbrController(context).getInstance();\n        initCache = InitCache(context).getInstance();\n        scheduleController = streamProcessor.getScheduleController();\n        requiredQuality = abrController.getQualityFor(type, streamProcessor.getStreamInfo());\n\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, this);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, this);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, this);\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, this, EventBus.EVENT_PRIORITY_HIGH);\n        eventBus.on(Events.SOURCEBUFFER_APPEND_COMPLETED, onAppended, this);\n        eventBus.on(Events.SOURCEBUFFER_REMOVE_COMPLETED, onRemoved, this);\n    }\n\n    function createBuffer(mediaInfo) {\n        if (!mediaInfo || !mediaSource || !streamProcessor) return null;\n\n        let sourceBuffer = null;\n\n        try {\n            sourceBuffer = sourceBufferController.createSourceBuffer(mediaSource, mediaInfo);\n\n            if (sourceBuffer && sourceBuffer.hasOwnProperty('initialize')) {\n                sourceBuffer.initialize(type, this);\n            }\n        } catch (e) {\n            errHandler.mediaSourceError('Error creating ' + type + ' source buffer.');\n        }\n        setBuffer(sourceBuffer);\n        updateBufferTimestampOffset(streamProcessor.getRepresentationInfoForQuality(requiredQuality).MSETimeOffset);\n        return sourceBuffer;\n    }\n\n    function isActive() {\n        return streamProcessor.getStreamInfo().id === streamController.getActiveStreamInfo().id;\n    }\n\n    function onInitFragmentLoaded(e) {\n        if (e.fragmentModel !== streamProcessor.getFragmentModel()) return;\n        log('Init fragment finished loading saving to', type + '\\'s init cache');\n        initCache.save(e.chunk);\n        appendToBuffer(e.chunk);\n    }\n\n    function switchInitData(streamId, quality) {\n        const chunk = initCache.extract(streamId, type, quality);\n        if (chunk) {\n            appendToBuffer(chunk);\n        } else {\n            eventBus.trigger(Events.INIT_REQUESTED, {sender: instance});\n        }\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e.fragmentModel !== streamProcessor.getFragmentModel()) return;\n\n        const chunk = e.chunk;\n        const bytes = chunk.bytes;\n        const quality = chunk.quality;\n        const currentRepresentation = streamProcessor.getRepresentationInfoForQuality(quality);\n        const manifest = manifestModel.getValue();\n        const eventStreamMedia = adapter.getEventsFor(manifest, currentRepresentation.mediaInfo, streamProcessor);\n        const eventStreamTrack = adapter.getEventsFor(manifest, currentRepresentation, streamProcessor);\n\n        if (eventStreamMedia && eventStreamMedia.length > 0 || eventStreamTrack && eventStreamTrack.length > 0) {\n            const request = streamProcessor.getFragmentModel().getRequests({\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\n                quality: quality,\n                index: chunk.index\n            })[0];\n            const events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack);\n            streamProcessor.getEventController().addInbandEvents(events);\n        }\n\n        chunk.bytes = deleteInbandEvents(bytes);\n        appendToBuffer(chunk);\n    }\n\n\n    function appendToBuffer(chunk) {\n        isAppendingInProgress = true;\n        appendedBytesInfo = chunk;\n        sourceBufferController.append(buffer, chunk);\n\n        if (chunk.mediaInfo.type === 'video') {\n            if (chunk.mediaInfo.embeddedCaptions) {\n                textSourceBuffer.append(chunk.bytes, chunk);\n            }\n        }\n    }\n\n    function onAppended(e) {\n        if (buffer !== e.buffer) return;\n\n        if (e.error || !hasEnoughSpaceToAppend()) {\n            if (e.error.code === SourceBufferController.QUOTA_EXCEEDED_ERROR_CODE) {\n                criticalBufferLevel = sourceBufferController.getTotalBufferedTime(buffer) * 0.8;\n            }\n            if (e.error.code === SourceBufferController.QUOTA_EXCEEDED_ERROR_CODE || !hasEnoughSpaceToAppend()) {\n                eventBus.trigger(Events.QUOTA_EXCEEDED, {sender: instance, criticalBufferLevel: criticalBufferLevel}); //Tells ScheduleController to stop scheduling.\n                clearBuffer(getClearRange()); // Then we clear the buffer and onCleared event will tell ScheduleController to start scheduling again.\n            }\n            return;\n        }\n\n        if (!isNaN(appendedBytesInfo.index)) {\n            maxAppendedIndex = Math.max(appendedBytesInfo.index, maxAppendedIndex);\n            checkIfBufferingCompleted();\n        }\n\n        const ranges = sourceBufferController.getAllRanges(buffer);\n        if (ranges && ranges.length > 0) {\n            for (let i = 0, len = ranges.length; i < len; i++) {\n                log('Buffered Range for type:', type , ':' ,ranges.start(i) ,  ' - ' ,  ranges.end(i));\n            }\n        }\n\n        onPlaybackProgression();\n        isAppendingInProgress = false;\n        eventBus.trigger(Events.BYTES_APPENDED, {\n            sender: instance,\n            quality: appendedBytesInfo.quality,\n            startTime: appendedBytesInfo.start,\n            index: appendedBytesInfo.index,\n            bufferedRanges: ranges\n        });\n    }\n\n    function onQualityChanged(e) {\n        if (requiredQuality === e.newQuality || type !== e.mediaType || streamProcessor.getStreamInfo().id !== e.streamInfo.id) return;\n\n        updateBufferTimestampOffset(streamProcessor.getRepresentationInfoForQuality(e.newQuality).MSETimeOffset);\n        requiredQuality = e.newQuality;\n    }\n\n    //**********************************************************************\n    // START Buffer Level, State & Sufficiency Handling.\n    //**********************************************************************\n    function onPlaybackSeeking() {\n        lastIndex = Number.POSITIVE_INFINITY;\n        isBufferingCompleted = false;\n        onPlaybackProgression();\n    }\n\n    function onPlaybackProgression() {\n        updateBufferLevel();\n        addBufferMetrics();\n    }\n\n    function updateBufferLevel() {\n        bufferLevel = sourceBufferController.getBufferLength(buffer, playbackController.getTime());\n        eventBus.trigger(Events.BUFFER_LEVEL_UPDATED, {sender: instance, bufferLevel: bufferLevel});\n        checkIfSufficientBuffer();\n    }\n\n    function addBufferMetrics() {\n        if (!isActive()) return;\n        metricsModel.addBufferState(type, bufferState, scheduleController.getBufferTarget());\n        metricsModel.addBufferLevel(type, new Date(), bufferLevel * 1000);\n    }\n\n    function checkIfBufferingCompleted() {\n        const isLastIdxAppended = maxAppendedIndex >= lastIndex - 1; // Handles 0 and non 0 based request index\n        if (isLastIdxAppended && !isBufferingCompleted) {\n            isBufferingCompleted = true;\n            eventBus.trigger(Events.BUFFERING_COMPLETED, {sender: instance, streamInfo: streamProcessor.getStreamInfo()});\n        }\n    }\n\n    function checkIfSufficientBuffer() {\n        if (bufferLevel < STALL_THRESHOLD && !isBufferingCompleted) {\n            notifyBufferStateChanged(BUFFER_EMPTY);\n        } else {\n            notifyBufferStateChanged(BUFFER_LOADED);\n        }\n    }\n\n    function notifyBufferStateChanged(state) {\n        if (bufferState === state || (type === 'fragmentedText' && textSourceBuffer.getAllTracksAreDisabled())) return;\n        bufferState = state;\n        addBufferMetrics();\n        eventBus.trigger(Events.BUFFER_LEVEL_STATE_CHANGED, {sender: instance, state: state, mediaType: type, streamInfo: streamProcessor.getStreamInfo()});\n        eventBus.trigger(state === BUFFER_LOADED ? Events.BUFFER_LOADED : Events.BUFFER_EMPTY, {mediaType: type});\n        log(state === BUFFER_LOADED ? 'Got enough buffer to start.' : 'Waiting for more buffer before starting playback.');\n    }\n\n\n    function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) {\n\n        const fragmentStartTime = Math.max(isNaN(request.startTime) ? 0 : request.startTime, 0);\n        const eventStreams = [];\n        const events = [];\n\n        inbandEventFound = false; //TODO Discuss why this is hear!\n        /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\n        const inbandEvents = mediaInbandEvents.concat(trackInbandEvents);\n        for (let i = 0, ln = inbandEvents.length; i < ln; i++) {\n            eventStreams[inbandEvents[i].schemeIdUri] = inbandEvents[i];\n        }\n\n        const isoFile = BoxParser(context).getInstance().parse(data);\n        const eventBoxes = isoFile.getBoxes('emsg');\n\n        for (let i = 0, ln = eventBoxes.length; i < ln; i++) {\n            const event = adapter.getEvent(eventBoxes[i], eventStreams, fragmentStartTime);\n\n            if (event) {\n                events.push(event);\n            }\n        }\n\n        return events;\n    }\n\n    function deleteInbandEvents(data) {\n\n        if (!inbandEventFound) { //TODO Discuss why this is here. inbandEventFound is never set to true!!\n            return data;\n        }\n\n        const length = data.length;\n        const expTwo = Math.pow(256, 2);\n        const expThree = Math.pow(256, 3);\n        const modData = new Uint8Array(data.length);\n\n        let i = 0;\n        let j = 0;\n\n        while (i < length) {\n\n            let identifier = String.fromCharCode(data[i + 4],data[i + 5],data[i + 6],data[i + 7]);\n            let size = data[i] * expThree + data[i + 1] * expTwo + data[i + 2] * 256 + data[i + 3] * 1;\n\n            if (identifier != 'emsg' ) {\n                for (let l = i ; l < i + size; l++) {\n                    modData[j] = data[l];\n                    j++;\n                }\n            }\n            i += size;\n\n        }\n\n        return modData.subarray(0, j);\n    }\n\n    function hasEnoughSpaceToAppend() {\n        var totalBufferedTime = sourceBufferController.getTotalBufferedTime(buffer);\n        return (totalBufferedTime < criticalBufferLevel);\n    }\n\n    /* prune buffer on our own in background to avoid browsers pruning buffer silently */\n    function pruneBuffer() {\n        if (!buffer) return;\n        if (type === 'fragmentedText') return;\n        const start = buffer.buffered.length ? buffer.buffered.start(0) : 0;\n        const bufferToPrune = playbackController.getTime() - start - mediaPlayerModel.getBufferToKeep();\n        if (bufferToPrune > 0) {\n            log('pruning buffer: ' + bufferToPrune + ' seconds.');\n            isPruningInProgress = true;\n            sourceBufferController.remove(buffer, 0, Math.round(start + bufferToPrune), mediaSource);\n        }\n    }\n\n    function getClearRange() {\n\n        if (!buffer) return null;\n\n        // we need to remove data that is more than one fragment before the video currentTime\n        const currentTime = playbackController.getTime();\n        const req = streamProcessor.getFragmentModel().getRequests({state: FragmentModel.FRAGMENT_MODEL_EXECUTED, time: currentTime, })[0];\n        const range = sourceBufferController.getBufferRange(buffer, currentTime);\n\n        let removeEnd = (req && !isNaN(req.startTime)) ? req.startTime : Math.floor(currentTime);\n        if ((range === null) && (buffer.buffered.length > 0)) {\n            removeEnd = buffer.buffered.end(buffer.buffered.length - 1 );\n        }\n\n        return {start: buffer.buffered.start(0), end: removeEnd};\n    }\n\n    function clearBuffer(range) {\n        if (!range || !buffer) return;\n        sourceBufferController.remove(buffer, range.start, range.end, mediaSource);\n    }\n\n    function onRemoved(e) {\n        if (buffer !== e.buffer) return;\n\n        if (isPruningInProgress) {\n            isPruningInProgress = false;\n        }\n\n        updateBufferLevel();\n        eventBus.trigger(Events.BUFFER_CLEARED, {sender: instance, from: e.from, to: e.to, hasEnoughSpaceToAppend: hasEnoughSpaceToAppend()});\n        //TODO - REMEMBER removed a timerout hack calling clearBuffer after manifestInfo.minBufferTime * 1000 if !hasEnoughSpaceToAppend() Aug 04 2016\n    }\n\n    function updateBufferTimestampOffset(MSETimeOffset) {\n        // Each track can have its own @presentationTimeOffset, so we should set the offset\n        // if it has changed after switching the quality or updating an mpd\n        if (buffer && buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            buffer.timestampOffset = MSETimeOffset;\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.sender.getStreamProcessor() !== streamProcessor || e.error) return;\n        updateBufferTimestampOffset(e.currentRepresentation.MSETimeOffset);\n    }\n\n    function onStreamCompleted(e) {\n        if (e.fragmentModel !== streamProcessor.getFragmentModel()) return;\n        lastIndex = e.request.index;\n        checkIfBufferingCompleted();\n    }\n\n    function onCurrentTrackChanged(e) {\n        if (!buffer || (e.newMediaInfo.type !== type) || (e.newMediaInfo.streamInfo.id !== streamProcessor.getStreamInfo().id)) return;\n        if (mediaController.getSwitchMode(type) === MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE) {\n            clearBuffer(getClearRange());\n        }\n    }\n\n    function onWallclockTimeUpdated() {\n        wallclockTicked++;\n        const secondsElapsed = (wallclockTicked * (mediaPlayerModel.getWallclockTimeUpdateInterval() / 1000));\n        if ((secondsElapsed >= mediaPlayerModel.getBufferPruningInterval()) && !isAppendingInProgress) {\n            wallclockTicked = 0;\n            pruneBuffer();\n        }\n    }\n\n    function onPlaybackRateChanged() {\n        checkIfSufficientBuffer();\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamProcessor() {\n        return streamProcessor;\n    }\n\n    function setStreamProcessor(value) {\n        streamProcessor = value;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function setBuffer(value) {\n        buffer = value;\n    }\n\n    function getBufferLevel() {\n        return bufferLevel;\n    }\n\n    function getCriticalBufferLevel() {\n        return criticalBufferLevel;\n    }\n\n    function setMediaSource(value) {\n        mediaSource = value;\n    }\n\n    function getMediaSource() {\n        return mediaSource;\n    }\n\n    function getIsBufferingCompleted() {\n        return isBufferingCompleted;\n    }\n\n    function reset(errored) {\n\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\n        eventBus.off(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, this);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, this);\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, this);\n        eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, this);\n        eventBus.off(Events.SOURCEBUFFER_APPEND_COMPLETED, onAppended, this);\n        eventBus.off(Events.SOURCEBUFFER_REMOVE_COMPLETED, onRemoved, this);\n\n        criticalBufferLevel = Number.POSITIVE_INFINITY;\n        bufferState = BUFFER_EMPTY;\n        requiredQuality = AbrController.QUALITY_DEFAULT;\n        lastIndex = Number.POSITIVE_INFINITY;\n        maxAppendedIndex = 0;\n        appendedBytesInfo = null;\n        appendingMediaChunk = false;\n        isBufferingCompleted = false;\n        isAppendingInProgress = false;\n        isPruningInProgress = false;\n        playbackController = null;\n        streamProcessor = null;\n        abrController = null;\n        scheduleController = null;\n\n        if (!errored) {\n            sourceBufferController.abort(mediaSource, buffer);\n            sourceBufferController.removeSourceBuffer(mediaSource, buffer);\n        }\n\n        buffer = null;\n    }\n\n    instance = {\n        initialize: initialize,\n        createBuffer: createBuffer,\n        getType: getType,\n        getStreamProcessor: getStreamProcessor,\n        setStreamProcessor: setStreamProcessor,\n        getBuffer: getBuffer,\n        setBuffer: setBuffer,\n        getBufferLevel: getBufferLevel,\n        getCriticalBufferLevel: getCriticalBufferLevel,\n        setMediaSource: setMediaSource,\n        getMediaSource: getMediaSource,\n        getIsBufferingCompleted: getIsBufferingCompleted,\n        switchInitData: switchInitData,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBufferController.__dashjs_factory_name = 'BufferController';\nconst factory = FactoryMaker.getClassFactory(BufferController);\nfactory.BUFFER_LOADED = BUFFER_LOADED;\nfactory.BUFFER_EMPTY = BUFFER_EMPTY;\nexport default factory;\n"]}