{"version":3,"sources":["../../../../../src/streaming/utils/EBMLParser.js"],"names":[],"mappings":"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","file":"EBMLParser.js","sourcesContent":["import FactoryMaker from '../../core/FactoryMaker';\nimport Error from '../vo/Error';\n\n/**\n * Creates an instance of an EBMLParser class which implements a large subset\n * of the functionality required to parse Matroska EBML\n *\n * @param {Object} config object with data member which is the buffer to parse\n */\nfunction EBMLParser(config) {\n\n    let instance;\n\n    let data = new DataView(config.data);\n    let pos = 0;\n\n    function getPos() {\n        return pos;\n    }\n\n    function setPos(value) {\n        pos = value;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n     * {boolean} required flag.\n     * @param {boolean} test whether or not the function should throw if a required\n     * tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test\n     * param is false or undefined, or if the stream is malformed.\n     * @memberof EBMLParser\n     */\n    function consumeTag(tag, test) {\n        let found = true;\n        let bytesConsumed = 0;\n        let p1;\n        let p2;\n\n        if (test === undefined) {\n            test = false;\n        }\n\n        if (tag.tag > 0xFFFFFF) {\n            if (data.getUint32(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 4;\n        } else if (tag.tag > 0xFFFF) {\n            // 3 bytes\n            p1 = data.getUint16(pos);\n            p2 = data.getUint8(pos + 2);\n\n            // shift p1 over a byte and add p2\n            if (p1 * 256 + p2 !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 3;\n        } else if (tag.tag > 0xFF) {\n            if (data.getUint16(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 2;\n        } else {\n            if (data.getUint8(pos) !== tag.tag) {\n                found = false;\n            }\n            bytesConsumed = 1;\n        }\n\n        if (!found && tag.required && !test) {\n            throw new Error('required tag not found');\n        }\n\n        if (found) {\n            pos += bytesConsumed;\n        }\n\n        return found;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\n     * {boolean} required flag.\n     * @param {boolean} test whether or not the function should throw if a required\n     * tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test\n     * param is false or undefined, or if the stream is malformedata.\n     * @memberof EBMLParser\n     */\n    function consumeTagAndSize(tag, test) {\n        let found = consumeTag(tag, test);\n\n        if (found) {\n            getMatroskaCodedNum();\n        }\n\n        return found;\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.  It will use the value of the size field to parse a binary\n     * field, using a parser defined in the tag itself\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag,\n     * {boolean} required flag, and a parse function which takes a size parameter\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found,\n     * or if the stream is malformed\n     * @memberof EBMLParser\n     */\n    function parseTag(tag) {\n        let size;\n\n        consumeTag(tag);\n        size = getMatroskaCodedNum();\n        return instance[tag.parse](size);\n    }\n\n    /**\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\n     * function will also remove the size field which follows the tag from the\n     * data stream.  It will use the value of the size field to skip over the\n     * entire section of EBML encapsulated by the tag.\n     *\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag, and\n     * {boolean} required flag\n     * @param {boolean} test a flag to indicate if an exception should be thrown\n     * if a required tag is not found\n     * @return {boolean} whether or not the tag was found\n     * @throws will throw an exception if a required tag is not found and test is\n     * false or undefined or if the stream is malformed\n     * @memberof EBMLParser\n     */\n    function skipOverElement(tag, test) {\n        let found = consumeTag(tag, test);\n        let headerSize;\n\n        if (found) {\n            headerSize = getMatroskaCodedNum();\n            pos += headerSize;\n        }\n\n        return found;\n    }\n\n    /**\n     * Returns and consumes a number encoded according to the Matroska EBML\n     * specification from the bitstream.\n     *\n     * @param {boolean} retainMSB whether or not to retain the Most Significant Bit (the\n     * first 1). this is usually true when reading Tag IDs.\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaCodedNum(retainMSB) {\n        let bytesUsed = 1;\n        let mask = 0x80;\n        let maxBytes = 8;\n        let extraBytes = -1;\n        let num = 0;\n        let ch = data.getUint8(pos);\n        let i;\n\n        for (i = 0; i < maxBytes; i += 1) {\n            if ((ch & mask) === mask) {\n                num = (retainMSB === undefined) ? ch & ~mask : ch;\n                extraBytes = i;\n                break;\n            }\n            mask >>= 1;\n        }\n\n        for (i = 0; i < extraBytes; i += 1, bytesUsed += 1) {\n            num = (num << 8) | (0xff & data.getUint8(pos + bytesUsed));\n        }\n\n        pos += bytesUsed;\n\n        return num;\n    }\n\n    /**\n     * Returns and consumes a float from the bitstream.\n     *\n     * @param {number} size 4 or 8 byte floats are supported\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaFloat(size) {\n        let outFloat;\n\n        switch (size) {\n        case 4:\n            outFloat = data.getFloat32(pos);\n            pos += 4;\n            break;\n        case 8:\n            outFloat = data.getFloat64(pos);\n            pos += 8;\n            break;\n        }\n        return outFloat;\n    }\n\n    /**\n     * Consumes and returns an unsigned int from the bitstream.\n     *\n     * @param {number} size 1 to 8 bytes\n     * @return {number} the decoded number\n     * @throws will throw an exception if the bit stream is malformed or there is\n     * not enough data\n     * @memberof EBMLParser\n     */\n    function getMatroskaUint(size) {\n        let val = 0;\n        let i;\n\n        for (i = 0; i < size; i += 1) {\n            val <<= 8;\n            val |= data.getUint8(pos + i) & 0xff;\n        }\n\n        pos += size;\n        return val;\n    }\n\n    /**\n     * Tests whether there is more data in the bitstream for parsing\n     *\n     * @return {boolean} whether there is more data to parse\n     * @memberof EBMLParser\n     */\n    function moreData() {\n        return pos < data.byteLength;\n    }\n\n    instance = {\n        getPos: getPos,\n        setPos: setPos,\n        consumeTag: consumeTag,\n        consumeTagAndSize: consumeTagAndSize,\n        parseTag: parseTag,\n        skipOverElement: skipOverElement,\n        getMatroskaCodedNum: getMatroskaCodedNum,\n        getMatroskaFloat: getMatroskaFloat,\n        getMatroskaUint: getMatroskaUint,\n        moreData: moreData\n    };\n\n    return instance;\n}\n\nEBMLParser.__dashjs_factory_name = 'EBMLParser';\nexport default FactoryMaker.getClassFactory(EBMLParser);"]}