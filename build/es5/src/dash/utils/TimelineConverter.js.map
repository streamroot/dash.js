{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":[],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction TimelineConverter() {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function initialize() {\n\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n    }\n\n    function isTimeSyncCompleted() {\n        return isClientServerTimeSyncCompleted;\n    }\n\n    function setTimeSyncCompleted(value) {\n        isClientServerTimeSyncCompleted = value;\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        //console.log(\"XXX\", wallTime.getTime() - period.mpd.availabilityStartTime.getTime(), clientServerTimeShift * 1000, clientServerTimeShift, period.mpd.availabilityStartTime.getTime())\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = { start: voPeriod.start, end: voPeriod.start + voPeriod.duration };\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        //Dyanmic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n        range.end = now >= periodEnd && now - d < periodEnd ? periodEnd - d : now - d;\n\n        return range;\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    function calcMpdRelativeTimeFromPeriodRelativeTime(representation, periodRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n\n        return periodRelativeTime + periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function onTimeSyncComplete(e) {\n\n        if (isClientServerTimeSyncCompleted) return;\n\n        if (e.offset !== undefined) {\n\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n\n        }\n    }\n\n    function calcMSETimeOffset(representation) {\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n        const presentationOffset = representation.presentationTimeOffset;\n        const periodStart = representation.adaptation.period.start;\n        return (periodStart - presentationOffset);\n    }\n\n    function reset() {\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    instance = {\n        initialize: initialize,\n        isTimeSyncCompleted: isTimeSyncCompleted,\n        setTimeSyncCompleted: setTimeSyncCompleted,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMpdRelativeTimeFromPeriodRelativeTime: calcMpdRelativeTimeFromPeriodRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        calcMSETimeOffset: calcMSETimeOffset,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);"]}