{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":[],"mappings":"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","file":"SegmentsUtils.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Segment from './../vo/Segment';\n\nfunction zeroPadToLength(numStr, minStrLength) {\n    while (numStr.length < minStrLength) {\n        numStr = '0' + numStr;\n    }\n    return numStr;\n}\n\nfunction getNumberForSegment(segment, segmentIndex) {\n    return segment.representation.startNumber + segmentIndex;\n}\n\nexport function replaceTokenForTemplate(url, token, value) {\n    const formatTag = '%0';\n\n    let startPos,\n        endPos,\n        formatTagPos,\n        specifier,\n        width,\n        paddedValue;\n\n    const tokenLen = token.length;\n    const formatTagLen = formatTag.length;\n\n    if (!url) {\n        return url;\n    }\n\n    // keep looping round until all instances of <token> have been\n    // replaced. once that has happened, startPos below will be -1\n    // and the completed url will be returned.\n    while (true) {\n\n        // check if there is a valid $<token>...$ identifier\n        // if not, return the url as is.\n        startPos = url.indexOf('$' + token);\n        if (startPos < 0) {\n            return url;\n        }\n\n        // the next '$' must be the end of the identifier\n        // if there isn't one, return the url as is.\n        endPos = url.indexOf('$', startPos + tokenLen);\n        if (endPos < 0) {\n            return url;\n        }\n\n        // now see if there is an additional format tag suffixed to\n        // the identifier within the enclosing '$' characters\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n        if (formatTagPos > startPos && formatTagPos < endPos) {\n\n            specifier = url.charAt(endPos - 1);\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n            // support the minimum specifiers required by IEEE 1003.1\n            // (d, i , o, u, x, and X) for completeness\n            switch (specifier) {\n                // treat all int types as uint,\n                // hence deliberate fallthrough\n                case 'd':\n                case 'i':\n                case 'u':\n                    paddedValue = zeroPadToLength(value.toString(), width);\n                    break;\n                case 'x':\n                    paddedValue = zeroPadToLength(value.toString(16), width);\n                    break;\n                case 'X':\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                    break;\n                case 'o':\n                    paddedValue = zeroPadToLength(value.toString(8), width);\n                    break;\n                default:\n                    //TODO: commented out logging to supress jshint warning -- `log` is undefined here\n                    //log('Unsupported/invalid IEEE 1003.1 format identifier string in URL');\n                    return url;\n            }\n        } else {\n            paddedValue = value;\n        }\n\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n    }\n}\n\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n    let seg,\n        duration,\n        presentationStartTime,\n        presentationEndTime;\n\n    duration = representation.segmentDuration;\n\n    /*\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n     * in the same way as for the last Media Segment in the Representation.\n     */\n    if (isNaN(duration)) {\n        duration = representation.adaptation.period.duration;\n    }\n\n    presentationStartTime = representation.adaptation.period.start + (index * duration);\n    presentationEndTime = presentationStartTime + duration;\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = duration;\n    seg.presentationStartTime = presentationStartTime;\n\n    seg.mediaStartTime = timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);\n\n    seg.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n    const scaledTime = time / fTimescale;\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n\n    let presentationStartTime,\n        presentationEndTime,\n        seg;\n\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n    presentationEndTime = presentationStartTime + scaledDuration;\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = scaledDuration;\n    seg.mediaStartTime = scaledTime;\n\n    seg.presentationStartTime = presentationStartTime;\n\n    // For SegmentTimeline every segment is available at loadedTime\n    seg.availabilityStartTime = representation.adaptation.period.mpd.manifest.loadedTime;\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementTime = tManifest ? tManifest : time;\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n    seg.media = url;\n    seg.mediaRange = range;\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getSegmentByIndex(index, representation) {\n    if (!representation || !representation.segments) return null;\n\n    const ln = representation.segments.length;\n    let seg,\n        i;\n\n    if (index < ln) {\n        seg = representation.segments[index];\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    for (i = 0; i < ln; i++) {\n        seg = representation.segments[i];\n\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    return null;\n}\n\nexport function decideSegmentListRangeForTemplate(timelineConverter, isDynamic, representation, requestedTime, index, givenAvailabilityUpperLimit) {\n    const duration = representation.segmentDuration;\n    const minBufferTime = representation.adaptation.period.mpd.manifest.minBufferTime;\n    const availabilityWindow = representation.segmentAvailabilityRange;\n    let periodRelativeRange = {\n        start: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow.start),\n        end: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow.end)\n    };\n    const currentSegmentList = representation.segments;\n    const availabilityLowerLimit = 2 * duration;\n    const availabilityUpperLimit = givenAvailabilityUpperLimit || Math.max(2 * minBufferTime, 10 * duration);\n\n    let originAvailabilityTime = NaN;\n    let originSegment = null;\n\n    let start,\n        end,\n        range;\n\n    periodRelativeRange.start = Math.max(periodRelativeRange.start, 0);\n\n    if (isDynamic && !timelineConverter.isTimeSyncCompleted()) {\n        start = Math.floor(periodRelativeRange.start / duration);\n        end = Math.floor(periodRelativeRange.end / duration);\n        range = {start: start, end: end};\n        return range;\n    }\n\n    // if segments exist we should try to find the latest buffered time, which is the presentation time of the\n    // segment for the current index\n    if (currentSegmentList && currentSegmentList.length > 0) {\n        originSegment = getSegmentByIndex(index, representation);\n        if (originSegment) {\n            originAvailabilityTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, originSegment.presentationStartTime);\n        } else {\n            originAvailabilityTime = index > 0 ? index * duration :\n                timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, requestedTime);\n        }\n\n    } else {\n        // If no segments exist, but index > 0, it means that we switch to the other representation, so\n        // we should proceed from this time.\n        // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds\n        originAvailabilityTime = index > 0 ? index * duration : isDynamic ? periodRelativeRange.end : periodRelativeRange.start;\n    }\n\n    // segment list should not be out of the availability window range\n    start = Math.floor(Math.max(originAvailabilityTime - availabilityLowerLimit, periodRelativeRange.start) / duration);\n    end = Math.floor(Math.min(start + availabilityUpperLimit / duration, periodRelativeRange.end / duration));\n\n    range = {start: start, end: end};\n\n    return range;\n}\n"]}